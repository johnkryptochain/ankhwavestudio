// Copyright (c) 2025 Jema Technology.
// Distributed under the license specified in the root directory of this project.
/**
 * AnkhWaveStudio Web Service Worker
 * Comprehensive PWA support with offline capabilities, caching strategies,
 * background sync, push notifications, and file handling
 */

import { precacheAndRoute, cleanupOutdatedCaches, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute, NavigationRoute, Route } from 'workbox-routing';
import { CacheFirst, NetworkFirst, StaleWhileRevalidate, NetworkOnly } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { BackgroundSyncPlugin } from 'workbox-background-sync';
import { BroadcastUpdatePlugin } from 'workbox-broadcast-update';

declare let self: ServiceWorkerGlobalScope;

// ============================================================================
// Constants
// ============================================================================

const CACHE_NAMES = {
  STATIC: 'AnkhWaveStudio-static-v1',
  AUDIO_SAMPLES: 'AnkhWaveStudio-audio-samples-v1',
  WAVETABLES: 'AnkhWaveStudio-wavetables-v1',
  IMPULSE_RESPONSES: 'AnkhWaveStudio-impulse-responses-v1',
  API: 'AnkhWaveStudio-api-v1',
  FONTS: 'AnkhWaveStudio-fonts-v1',
  IMAGES: 'AnkhWaveStudio-images-v1',
  RUNTIME: 'AnkhWaveStudio-runtime-v1',
};

const OFFLINE_FALLBACK_PAGE = '/offline.html';
const APP_SHELL_URL = 'index.html';

// ============================================================================
// Precaching
// ============================================================================

// Precache all assets generated by the build process
precacheAndRoute(self.__WB_MANIFEST);

// Clean up old caches from previous versions
cleanupOutdatedCaches();

// ============================================================================
// Navigation Routes (App Shell)
// ============================================================================

// Handle navigation requests with app shell pattern
const navigationHandler = createHandlerBoundToURL(APP_SHELL_URL);
const navigationRoute = new NavigationRoute(navigationHandler, {
  // Don't use app shell for these paths
  denylist: [
    /\/api\//,
    /\/share/,
    /\/protocol/,
    /\/import/,
    /\/open/,
    /\/__/,
  ],
});
registerRoute(navigationRoute);

// ============================================================================
// Static Assets - Cache First
// ============================================================================

// JavaScript and CSS files
registerRoute(
  ({ request }) =>
    request.destination === 'script' ||
    request.destination === 'style',
  new CacheFirst({
    cacheName: CACHE_NAMES.STATIC,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// Fonts - Cache First with long expiration
registerRoute(
  ({ request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: CACHE_NAMES.FONTS,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year
      }),
    ],
  })
);

// Images - Cache First
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: CACHE_NAMES.IMAGES,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// ============================================================================
// Audio Assets - Cache First (Large files, rarely change)
// ============================================================================

// Audio samples
registerRoute(
  ({ request, url }) =>
    request.destination === 'audio' ||
    url.pathname.includes('/samples/'),
  new CacheFirst({
    cacheName: CACHE_NAMES.AUDIO_SAMPLES,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 500,
        maxAgeSeconds: 90 * 24 * 60 * 60, // 90 days
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// Wavetables
registerRoute(
  ({ url }) => url.pathname.includes('/wavetables/'),
  new CacheFirst({
    cacheName: CACHE_NAMES.WAVETABLES,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 90 * 24 * 60 * 60, // 90 days
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// Impulse responses for reverb
registerRoute(
  ({ url }) => url.pathname.includes('/impulse-responses/'),
  new CacheFirst({
    cacheName: CACHE_NAMES.IMPULSE_RESPONSES,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 90 * 24 * 60 * 60, // 90 days
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// ============================================================================
// API Routes - Network First with Background Sync
// ============================================================================

// Background sync plugin for project saves
const projectSyncPlugin = new BackgroundSyncPlugin('project-sync-queue', {
  maxRetentionTime: 24 * 60, // Retry for up to 24 hours
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        await fetch(entry.request);
        console.log('Background sync successful for:', entry.request.url);
        
        // Notify the app about successful sync
        const clients = await self.clients.matchAll();
        clients.forEach(client => {
          client.postMessage({
            type: 'SYNC_COMPLETE',
            url: entry.request.url,
          });
        });
      } catch (error) {
        console.error('Background sync failed:', error);
        await queue.unshiftRequest(entry);
        throw error;
      }
    }
  },
});

// API calls with network first and background sync
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: CACHE_NAMES.API,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 24 * 60 * 60, // 24 hours
      }),
      new BroadcastUpdatePlugin(),
    ],
    networkTimeoutSeconds: 10,
  })
);

// Project save endpoint with background sync
registerRoute(
  ({ url, request }) =>
    url.pathname.startsWith('/api/projects') && request.method === 'POST',
  new NetworkOnly({
    plugins: [projectSyncPlugin],
  }),
  'POST'
);

// ============================================================================
// External Resources - Stale While Revalidate
// ============================================================================

// Google Fonts
registerRoute(
  ({ url }) =>
    url.origin === 'https://fonts.googleapis.com' ||
    url.origin === 'https://fonts.gstatic.com',
  new StaleWhileRevalidate({
    cacheName: 'google-fonts',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year
      }),
    ],
  })
);

// CDN resources
registerRoute(
  ({ url }) =>
    url.origin.includes('cdn') ||
    url.origin.includes('unpkg') ||
    url.origin.includes('jsdelivr'),
  new StaleWhileRevalidate({
    cacheName: CACHE_NAMES.RUNTIME,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
      }),
    ],
  })
);

// ============================================================================
// Service Worker Lifecycle Events
// ============================================================================

// Install event - cache offline fallback
self.addEventListener('install', (event) => {
  console.log('[SW] Installing service worker...');
  
  event.waitUntil(
    (async () => {
      const cache = await caches.open(CACHE_NAMES.STATIC);
      
      // Cache offline fallback page
      await cache.add(new Request(OFFLINE_FALLBACK_PAGE, { cache: 'reload' }));
      
      // Cache app shell
      await cache.add(new Request(APP_SHELL_URL, { cache: 'reload' }));
      
      console.log('[SW] Offline fallback and app shell cached');
      
      // Skip waiting to activate immediately
      await self.skipWaiting();
    })()
  );
});

// Activate event - clean up old caches and take control
self.addEventListener('activate', (event) => {
  console.log('[SW] Activating service worker...');
  
  event.waitUntil(
    (async () => {
      // Clean up old caches
      const cacheNames = await caches.keys();
      const validCacheNames = Object.values(CACHE_NAMES);
      
      await Promise.all(
        cacheNames
          .filter(name => !validCacheNames.includes(name) && !name.startsWith('workbox-'))
          .map(name => {
            console.log('[SW] Deleting old cache:', name);
            return caches.delete(name);
          })
      );
      
      // Take control of all clients immediately
      await self.clients.claim();
      
      // Request persistent storage
      if (navigator.storage && navigator.storage.persist) {
        const isPersisted = await navigator.storage.persist();
        console.log('[SW] Persistent storage:', isPersisted ? 'granted' : 'denied');
      }
      
      console.log('[SW] Service worker activated');
    })()
  );
});

// ============================================================================
// Message Handling
// ============================================================================

self.addEventListener('message', (event) => {
  if (!event.data) return;
  
  const { type, payload } = event.data;
  
  switch (type) {
    case 'SKIP_WAITING':
      self.skipWaiting();
      break;
      
    case 'GET_VERSION':
      event.ports[0]?.postMessage({ version: '1.0.0' });
      break;
      
    case 'CACHE_URLS':
      event.waitUntil(cacheUrls(payload.urls));
      break;
      
    case 'CLEAR_CACHE':
      event.waitUntil(clearCache(payload?.cacheName));
      break;
      
    case 'GET_CACHE_SIZE':
      event.waitUntil(getCacheSize().then(size => {
        event.ports[0]?.postMessage({ size });
      }));
      break;
      
    case 'PRECACHE_SAMPLES':
      event.waitUntil(precacheSamples(payload.urls));
      break;
  }
});

// ============================================================================
// Fetch Event - Offline Fallback
// ============================================================================

self.addEventListener('fetch', (event) => {
  // Only handle GET requests for offline fallback
  if (event.request.method !== 'GET') return;
  
  // Handle navigation requests with offline fallback
  if (event.request.mode === 'navigate') {
    event.respondWith(
      (async () => {
        try {
          // Try to get from network first
          const preloadResponse = await event.preloadResponse;
          if (preloadResponse) {
            return preloadResponse;
          }
          
          return await fetch(event.request);
        } catch (error) {
          // Network failed, try cache
          const cachedResponse = await caches.match(event.request);
          if (cachedResponse) {
            return cachedResponse;
          }
          
          // Return offline fallback
          const offlineResponse = await caches.match(OFFLINE_FALLBACK_PAGE);
          if (offlineResponse) {
            return offlineResponse;
          }
          
          // Generate inline offline page as last resort
          return new Response(generateOfflinePage(), {
            headers: { 'Content-Type': 'text/html' },
          });
        }
      })()
    );
  }
});

// ============================================================================
// Background Sync
// ============================================================================

self.addEventListener('sync', (event: any) => {
  console.log('[SW] Background sync event:', event.tag);
  
  switch (event.tag) {
    case 'sync-projects':
      event.waitUntil(syncProjects());
      break;
      
    case 'sync-settings':
      event.waitUntil(syncSettings());
      break;
      
    case 'sync-samples':
      event.waitUntil(syncSamples());
      break;
  }
});

// Periodic background sync (if supported)
self.addEventListener('periodicsync', (event: any) => {
  console.log('[SW] Periodic sync event:', event.tag);
  
  switch (event.tag) {
    case 'check-updates':
      event.waitUntil(checkForUpdates());
      break;
      
    case 'sync-cloud':
      event.waitUntil(syncToCloud());
      break;
  }
});

// ============================================================================
// Push Notifications
// ============================================================================

self.addEventListener('push', (event) => {
  if (!event.data) return;
  
  let data;
  try {
    data = event.data.json();
  } catch {
    data = {
      title: 'AnkhWaveStudio Web',
      body: event.data.text(),
    };
  }
  
  const options: NotificationOptions = {
    body: data.body,
    icon: '/icons/icon-192x192.png',
    badge: '/icons/icon-72x72.png',
    vibrate: [100, 50, 100],
    tag: data.tag || 'AnkhWaveStudio-notification',
    renotify: data.renotify || false,
    requireInteraction: data.requireInteraction || false,
    silent: data.silent || false,
    data: {
      url: data.url || '/',
      action: data.action,
    },
    actions: data.actions || [
      { action: 'open', title: 'Open' },
      { action: 'dismiss', title: 'Dismiss' },
    ],
  };
  
  event.waitUntil(
    self.registration.showNotification(data.title || 'AnkhWaveStudio Web', options)
  );
});

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  const action = event.action;
  const url = event.notification.data?.url || '/';
  
  if (action === 'dismiss') {
    return;
  }
  
  event.waitUntil(
    (async () => {
      const clients = await self.clients.matchAll({ type: 'window' });
      
      // Check if there's already a window open
      for (const client of clients) {
        if (client.url === url && 'focus' in client) {
          return client.focus();
        }
      }
      
      // Open a new window
      if (self.clients.openWindow) {
        return self.clients.openWindow(url);
      }
    })()
  );
});

// Handle notification close
self.addEventListener('notificationclose', (event) => {
  // Track notification dismissal for analytics
  console.log('[SW] Notification closed:', event.notification.tag);
});

// ============================================================================
// File Handling (Launch Queue)
// ============================================================================

// Handle files opened via file_handlers
self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);
  
  // Handle file open requests
  if (url.pathname === '/open' || url.pathname === '/import') {
    event.respondWith(
      (async () => {
        // Get the app shell and let the client handle the file
        const response = await caches.match(APP_SHELL_URL);
        if (response) {
          return response;
        }
        return fetch(APP_SHELL_URL);
      })()
    );
  }
  
  // Handle share target
  if (url.pathname === '/share' && event.request.method === 'POST') {
    event.respondWith(
      (async () => {
        const formData = await event.request.formData();
        const files = formData.getAll('audio');
        
        // Store files temporarily for the client to pick up
        const cache = await caches.open('share-target-cache');
        for (const file of files) {
          if (file instanceof File) {
            const response = new Response(file);
            await cache.put(`/shared/${file.name}`, response);
          }
        }
        
        // Redirect to app with share indicator
        return Response.redirect('/?share=pending', 303);
      })()
    );
  }
});

// ============================================================================
// Helper Functions
// ============================================================================

async function cacheUrls(urls: string[]): Promise<void> {
  const cache = await caches.open(CACHE_NAMES.RUNTIME);
  await cache.addAll(urls);
  console.log('[SW] Cached URLs:', urls.length);
}

async function clearCache(cacheName?: string): Promise<void> {
  if (cacheName) {
    await caches.delete(cacheName);
    console.log('[SW] Cleared cache:', cacheName);
  } else {
    const names = await caches.keys();
    await Promise.all(names.map(name => caches.delete(name)));
    console.log('[SW] Cleared all caches');
  }
}

async function getCacheSize(): Promise<number> {
  if ('storage' in navigator && 'estimate' in navigator.storage) {
    const estimate = await navigator.storage.estimate();
    return estimate.usage || 0;
  }
  return 0;
}

async function precacheSamples(urls: string[]): Promise<void> {
  const cache = await caches.open(CACHE_NAMES.AUDIO_SAMPLES);
  
  for (const url of urls) {
    try {
      const response = await fetch(url);
      if (response.ok) {
        await cache.put(url, response);
      }
    } catch (error) {
      console.warn('[SW] Failed to precache sample:', url, error);
    }
  }
  
  console.log('[SW] Precached samples:', urls.length);
}

async function syncProjects(): Promise<void> {
  console.log('[SW] Syncing projects...');
  
  // Notify clients about sync start
  const clients = await self.clients.matchAll();
  clients.forEach(client => {
    client.postMessage({ type: 'SYNC_START', target: 'projects' });
  });
  
  // Implementation would sync pending project changes
  // This is a placeholder for the actual sync logic
  
  clients.forEach(client => {
    client.postMessage({ type: 'SYNC_COMPLETE', target: 'projects' });
  });
}

async function syncSettings(): Promise<void> {
  console.log('[SW] Syncing settings...');
  // Implementation for settings sync
}

async function syncSamples(): Promise<void> {
  console.log('[SW] Syncing samples...');
  // Implementation for sample library sync
}

async function checkForUpdates(): Promise<void> {
  console.log('[SW] Checking for updates...');
  
  try {
    const response = await fetch('/version.json', { cache: 'no-store' });
    if (response.ok) {
      const data = await response.json();
      
      // Notify clients about available update
      const clients = await self.clients.matchAll();
      clients.forEach(client => {
        client.postMessage({
          type: 'UPDATE_AVAILABLE',
          version: data.version,
          changelog: data.changelog,
        });
      });
    }
  } catch (error) {
    console.warn('[SW] Update check failed:', error);
  }
}

async function syncToCloud(): Promise<void> {
  console.log('[SW] Syncing to cloud...');
  // Implementation for cloud sync
}

function generateOfflinePage(): string {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AnkhWaveStudio Web - Offline</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #fff;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .container {
      text-align: center;
      padding: 2rem;
      max-width: 500px;
    }
    .icon {
      width: 120px;
      height: 120px;
      margin-bottom: 2rem;
      opacity: 0.8;
    }
    h1 {
      color: #4a9eff;
      font-size: 2rem;
      margin-bottom: 1rem;
    }
    p {
      color: #b0b0b0;
      line-height: 1.6;
      margin-bottom: 1.5rem;
    }
    .features {
      text-align: left;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 2rem;
    }
    .features h3 {
      color: #4a9eff;
      margin-bottom: 1rem;
      font-size: 1rem;
    }
    .features ul {
      list-style: none;
    }
    .features li {
      padding: 0.5rem 0;
      color: #b0b0b0;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .features li::before {
      content: "âœ“";
      color: #4ade80;
    }
    button {
      background: linear-gradient(135deg, #4a9eff 0%, #6366f1 100%);
      color: white;
      border: none;
      padding: 14px 32px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 20px rgba(74, 158, 255, 0.4);
    }
    button:active {
      transform: translateY(0);
    }
    .status {
      margin-top: 1rem;
      font-size: 0.875rem;
      color: #6b7280;
    }
  </style>
</head>
<body>
  <div class="container">
    <svg class="icon" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
      <circle cx="50" cy="50" r="45" stroke="#4a9eff" stroke-width="2" fill="none"/>
      <path d="M30 50 L45 65 L70 35" stroke="#4a9eff" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
    </svg>
    <h1>You're Offline</h1>
    <p>Don't worry! AnkhWaveStudio Web works offline. Your projects are saved locally and will sync when you're back online.</p>
    
    <div class="features">
      <h3>What you can do offline:</h3>
      <ul>
        <li>Continue working on saved projects</li>
        <li>Use all instruments and effects</li>
        <li>Access cached samples</li>
        <li>Export your work locally</li>
      </ul>
    </div>
    
    <button onclick="location.reload()">Try Again</button>
    <p class="status">Waiting for connection...</p>
  </div>
  
  <script>
    // Check for online status
    window.addEventListener('online', () => {
      location.reload();
    });
    
    // Update status periodically
    setInterval(() => {
      if (navigator.onLine) {
        location.reload();
      }
    }, 5000);
  </script>
</body>
</html>`;
}

// ============================================================================
// Export (required for TypeScript module)
// ============================================================================

export {};